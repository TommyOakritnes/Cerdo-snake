<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>El Cerdo de las Bellotas üê∑ ‚Äî m√≥vil + wrap</title>
<style>
  :root{ --gap: .8rem; }
  html,body{height:100%;margin:0;background:#0f0f13;color:#e8e8ea;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{display:flex;flex-direction:column;align-items:center;gap:var(--gap);padding:1rem}
  canvas{background:#151722;border:2px solid #2e3145;border-radius:12px;image-rendering:pixelated;touch-action:none}
  .row{display:flex;gap:.75rem;flex-wrap:wrap;align-items:center;justify-content:center}
  .btn{cursor:pointer;border:1px solid #2e3145;background:#1b1e2b;padding:.55rem .9rem;border-radius:8px;color:#cfd2ff}
  .muted{opacity:.85;font-size:.92rem;text-align:center;max-width:640px}
  .score{font-weight:700;letter-spacing:.5px}

  /* D-Pad t√°ctil */
  .pad{
    display:grid;grid-template-columns:64px 64px 64px;grid-template-rows:64px 64px 64px;
    gap:10px;user-select:none;-webkit-user-select:none;touch-action:none
  }
  .pad .pbtn{
    display:flex;align-items:center;justify-content:center;
    background:#1b1e2b;border:1px solid #2e3145;border-radius:14px;color:#cfd2ff;font-size:20px;
  }
  .pad .pbtn:active{transform:scale(0.98)}
  .pad .empty{background:transparent;border:none}
  @media (max-width: 520px){
    .pad{grid-template-columns:56px 56px 56px;grid-template-rows:56px 56px 56px}
    .pad .pbtn{font-size:18px}
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>El Cerdo de las Bellotas üê∑</h1>
  <div class="row">
    <button id="play" class="btn">‚ñ∂Ô∏è Jugar / Reiniciar</button>
    <span class="score">Puntuaci√≥n: <span id="score">0</span></span>
    <button id="pause" class="btn">‚è∏Ô∏è Pausa</button>
    <button id="sound" class="btn">üîä Sonido</button>
    <button id="wrapToggle" class="btn">üîÅ Wrap: ON</button>
  </div>

  <!-- Canvas: se redimensiona autom√°ticamente -->
  <canvas id="game" width="560" height="560"></canvas>

  <!-- Controles t√°ctiles -->
  <div class="pad" aria-label="Controles t√°ctiles">
    <div class="empty"></div>
    <button class="pbtn" id="up"   aria-label="Arriba">‚ñ≤</button>
    <div class="empty"></div>
    <button class="pbtn" id="left" aria-label="Izquierda">‚óÄ</button>
    <div class="empty"></div>
    <button class="pbtn" id="right" aria-label="Derecha">‚ñ∂</button>
    <div class="empty"></div>
    <button class="pbtn" id="down" aria-label="Abajo">‚ñº</button>
    <div class="empty"></div>
  </div>

  <div class="muted">
    Flechas o WASD para moverte ‚Ä¢ Espacio = Reiniciar ‚Ä¢ P = Pausa ‚Ä¢ En m√≥vil: D-Pad o desliza.
  </div>
</div>

<script>
(() => {
  // ====== DOM ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const playBtn = document.getElementById('play');
  const pauseBtn = document.getElementById('pause');
  const soundBtn = document.getElementById('sound');
  const scoreEl = document.getElementById('score');
  const wrapBtn = document.getElementById('wrapToggle');
  const upBtn = document.getElementById('up');
  const downBtn = document.getElementById('down');
  const leftBtn = document.getElementById('left');
  const rightBtn = document.getElementById('right');

  // ====== Config ======
  const COLS = 28;
  const ROWS = 28;
  let CELL = 20; // variable: se recalcula al redimensionar
  const SPEED_START_MS = 130;
  const SPEED_MIN_MS   = 70;
  const SPEED_STEP_MS  = 2;

  // ====== Estado ======
  let snake, dir, nextDir, acorn, score, tickMs, fatness, growth;
  let running = false;
  let paused = false;
  let lastTime = 0;
  let acc = 0;
  let wrapMode = true; // ON por defecto

  // Audio
  let audioEnabled = true;
  let audioCtx = null;

  // ====== Util ======
  const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
  const eqPos = (a, b) => a.x === b.x && a.y === b.y;

  function inBounds(x, y){ return x >= 0 && x < COLS && y >= 0 && y < ROWS; }

  function freeCell(occupied){
    while(true){
      const p = { x: randInt(0, COLS-1), y: randInt(0, ROWS-1) };
      if (!occupied.some(s => eqPos(s, p))) return p;
    }
  }

  // Redimensiona el canvas para m√≥vil/desktop y recalcula CELL
  function resizeCanvas(){
    const maxSide = Math.min(window.innerWidth - 24, 640); // margen visual
    const size = Math.max(300, Math.min(maxSide, window.innerHeight - 260)); // deja espacio a UI
    // Asegurar m√∫ltiplo limpio de la rejilla
    const cell = Math.floor(size / Math.max(COLS, ROWS));
    CELL = Math.max(12, cell); // l√≠mite inferior para no hacerlo min√∫sculo
    const px = CELL * COLS;
    canvas.width = px;
    canvas.height = px;
    draw();
  }
  window.addEventListener('resize', resizeCanvas);

  // ====== Audio ======
  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function playOing(){
    if (!audioEnabled) return;
    try{
      ensureAudio();
      const ctxA = audioCtx;
      const dur = 0.22;
      const osc1 = ctxA.createOscillator();
      const osc2 = ctxA.createOscillator();
      const gain = ctxA.createGain();

      osc1.type = 'square';
      osc2.type = 'sine';

      const t0 = ctxA.currentTime;
      const t1 = t0 + dur;

      osc1.frequency.setValueAtTime(180, t0);
      osc1.frequency.exponentialRampToValueAtTime(70, t1);
      osc2.frequency.setValueAtTime(240, t0);
      osc2.frequency.exponentialRampToValueAtTime(90, t1);

      gain.gain.setValueAtTime(0.0001, t0);
      gain.gain.exponentialRampToValueAtTime(0.35, t0 + 0.03);
      gain.gain.exponentialRampToValueAtTime(0.0001, t1);

      osc1.connect(gain); osc2.connect(gain); gain.connect(ctxA.destination);
      osc1.start(t0); osc2.start(t0); osc1.stop(t1); osc2.stop(t1);
      // vibraci√≥n ligera en m√≥vil compatible
      if (window.navigator && navigator.vibrate) navigator.vibrate(20);
    }catch(e){}
  }

  // ====== Dibujo ======
  function drawBoard(){
    ctx.fillStyle = '#12141d';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#1d2132';
    ctx.lineWidth = 1;
    for(let x=0;x<=COLS;x++){
      ctx.beginPath(); ctx.moveTo(x*CELL+.5, 0); ctx.lineTo(x*CELL+.5, ROWS*CELL); ctx.stroke();
    }
    for(let y=0;y<=ROWS;y++){
      ctx.beginPath(); ctx.moveTo(0, y*CELL+.5); ctx.lineTo(COLS*CELL, y*CELL+.5); ctx.stroke();
    }
  }
  function drawAcorn(x, y){
    const cx = x*CELL + CELL/2;
    const cy = y*CELL + CELL/2;
    const r = Math.floor(CELL*0.38);
    ctx.fillStyle = '#8b5a2b';
    ctx.beginPath(); ctx.ellipse(cx, cy+2, r, r*0.85, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#5b3a1a';
    ctx.beginPath(); ctx.ellipse(cx, cy - r*0.25, r*1.05, r*0.55, 0, Math.PI, 0); ctx.fill();
    ctx.strokeStyle = '#5b3a1a'; ctx.lineWidth = Math.max(1, Math.floor(CELL*0.06));
    ctx.beginPath(); ctx.moveTo(cx, cy - r*0.9);
    ctx.quadraticCurveTo(cx + r*0.3, cy - r*1.3, cx + r*0.05, cy - r*1.55);
    ctx.stroke();
  }
  function drawPigSegment(x, y, radius, isHead=false, dir={x:1,y:0}){
    const cx = x*CELL + CELL/2, cy = y*CELL + CELL/2;
    ctx.fillStyle = '#ff9db2';
    ctx.beginPath(); ctx.arc(cx, cy, radius, 0, Math.PI*2); ctx.fill();
    if (isHead){
      const nx = cx + (dir.x*radius*0.35), ny = cy + (dir.y*radius*0.35);
      ctx.fillStyle = '#ffb7c6';
      ctx.beginPath(); ctx.ellipse(nx, ny, radius*0.45, radius*0.33, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#7a3b4d';
      const dx = dir.y !== 0 ? radius*0.12 : radius*0.18;
      const dy = dir.x !== 0 ? radius*0.12 : radius*0.18;
      ctx.beginPath();
      ctx.arc(nx - dx, ny - dy, radius*0.08, 0, Math.PI*2);
      ctx.arc(nx + dx, ny + dy, radius*0.08, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ff9db2';
      const ex = cx - dir.y * radius*0.75, ey = cy + dir.x * radius*0.75;
      const ex2 = cx + dir.y * radius*0.75, ey2 = cy - dir.x * radius*0.75;
      ctx.beginPath();
      ctx.ellipse(ex,  ey,  radius*0.22, radius*0.32, 0, 0, Math.PI*2);
      ctx.ellipse(ex2, ey2, radius*0.22, radius*0.32, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#2a2230';
      const ox = cx + dir.x*radius*0.05 - dir.y*radius*0.25;
      const oy = cy + dir.y*radius*0.05 + dir.x*radius*0.25;
      const ox2= cx + dir.x*radius*0.05 + dir.y*radius*0.25;
      const oy2= cy + dir.y*radius*0.05 - dir.x*radius*0.25;
      ctx.beginPath(); ctx.arc(ox, oy, radius*0.08, 0, Math.PI*2);
      ctx.arc(ox2, oy2, radius*0.08, 0, Math.PI*2); ctx.fill();
    }
  }

  // ====== Juego ======
  function reset(){
    snake = [
      {x: Math.floor(COLS/2)-1, y: Math.floor(ROWS/2)},
      {x: Math.floor(COLS/2)-2, y: Math.floor(ROWS/2)},
      {x: Math.floor(COLS/2)-3, y: Math.floor(ROWS/2)}
    ];
    dir = {x:1,y:0};
    nextDir = {...dir};
    score = 0; scoreEl.textContent = score;
    tickMs = SPEED_START_MS;
    fatness = 0;
    growth = 0;
    acorn = freeCell(snake);
    running = true; paused = false;
    lastTime = 0; acc = 0;
    draw();
  }

  function setPause(p){ paused = p; pauseBtn.textContent = paused ? '‚ñ∂Ô∏è Reanudar' : '‚è∏Ô∏è Pausa'; }

  function step(){
    // Actualiza direcci√≥n (sin reversa instant√°nea)
    if (Math.abs(nextDir.x) !== Math.abs(dir.x) || Math.abs(nextDir.y) !== Math.abs(dir.y)){
      if (!(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;
    }

    const head = snake[0];
    let nx = head.x + dir.x;
    let ny = head.y + dir.y;

    // --- Modo wrap: atraviesa paredes ---
    if (wrapMode){
      nx = (nx + COLS) % COLS;
      ny = (ny + ROWS) % ROWS;
    } else {
      if (!inBounds(nx, ny)) return gameOver();
    }

    // Choque contra s√≠ mismo
    if (snake.some((s,i)=> i>0 && s.x===nx && s.y===ny)) return gameOver();

    snake.unshift({x:nx, y:ny});

    if (nx === acorn.x && ny === acorn.y){
      score++; scoreEl.textContent = score;
      growth += 1;
      fatness = Math.min(fatness + 1, 20);
      tickMs = Math.max(SPEED_MIN_MS, tickMs - SPEED_STEP_MS);
      acorn = freeCell(snake);
      playOing();
    }

    if (growth > 0) growth--;
    else snake.pop();
  }

  function gameOver(){ running = false; paused = false; draw(true); }

  function draw(isGameOver=false){
    drawBoard();
    drawAcorn(acorn.x, acorn.y);

    const baseR = CELL*0.38;
    const extra = Math.min(fatness*0.02*CELL, CELL*0.22);
    const headDir = dir;

    snake.forEach((seg, i) => {
      const r = baseR + extra * (i===0 ? 1 : 0.75);
      ctx.save();
      ctx.shadowColor = '#ff6f92';
      ctx.shadowBlur = Math.max(0, (fatness*0.3));
      drawPigSegment(seg.x, seg.y, r, i===0, i===0 ? headDir : {x:0,y:0});
      ctx.restore();
    });

    if (!running || isGameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.55)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#ffffff'; ctx.textAlign = 'center';
      ctx.font = 'bold 28px system-ui,Segoe UI,Roboto,Arial';
      ctx.fillText(isGameOver ? 'üíÄ ¬°Has perdido!' : 'üê∑ El Cerdo de las Bellotas', canvas.width/2, canvas.height/2 - 10);
      ctx.font = '16px system-ui,Segoe UI,Roboto,Arial';
      ctx.fillText('Espacio o ‚ñ∂Ô∏è para reiniciar', canvas.width/2, canvas.height/2 + 22);
    }
  }

  // ====== Loop ======
  function loop(ts){
    if (!running){ draw(); return; }
    if (paused){ draw(); requestAnimationFrame(loop); return; }

    if (!lastTime) lastTime = ts;
    const dt = ts - lastTime; lastTime = ts; acc += dt;

    while (acc >= tickMs){ step(); acc -= tickMs; }
    draw();
    requestAnimationFrame(loop);
  }

  // ====== Controles teclado ======
  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'arrowup' || k === 'w') nextDir = {x:0,y:-1};
    else if (k === 'arrowdown' || k === 's') nextDir = {x:0,y:1};
    else if (k === 'arrowleft' || k === 'a') nextDir = {x:-1,y:0};
    else if (k === 'arrowright' || k === 'd') nextDir = {x:1,y:0};
    else if (k === ' ') { reset(); requestAnimationFrame(loop); }
    else if (k === 'p') setPause(!paused);
  });

  // ====== Controles t√°ctiles: botones ======
  function tapDir(vec){ nextDir = vec; }
  ;[upBtn,downBtn,leftBtn,rightBtn].forEach(btn => {
    btn.addEventListener('touchstart', (ev)=>{ ev.preventDefault(); btn.click(); }, {passive:false});
  });
  upBtn.onclick    = ()=> tapDir({x:0,y:-1});
  downBtn.onclick  = ()=> tapDir({x:0,y:1});
  leftBtn.onclick  = ()=> tapDir({x:-1,y:0});
  rightBtn.onclick = ()=> tapDir({x:1,y:0});

  // ====== Gestos: deslizamiento (swipe) ======
  let touchStart = null;
  canvas.addEventListener('touchstart', (e)=>{
    if (!running) return;
    const t = e.changedTouches[0];
    touchStart = {x:t.clientX, y:t.clientY, t:performance.now()};
  }, {passive:true});
  canvas.addEventListener('touchend', (e)=>{
    if (!touchStart) return;
    const t = e.changedTouches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const ax = Math.abs(dx), ay = Math.abs(dy);
    if (Math.max(ax, ay) > 24){ // umbral
      if (ax > ay) nextDir = {x: dx>0 ? 1 : -1, y:0};
      else nextDir = {x:0, y: dy>0 ? 1 : -1};
    }
    touchStart = null;
  }, {passive:true});

  // ====== Botones UI ======
  playBtn.addEventListener('click', () => { ensureAudio(); reset(); requestAnimationFrame(loop); });
  pauseBtn.addEventListener('click', () => { if (running) setPause(!paused); });
  soundBtn.addEventListener('click', () => {
    audioEnabled = !audioEnabled;
    soundBtn.textContent = audioEnabled ? 'üîä Sonido' : 'üîá Silencio';
    if (audioEnabled) ensureAudio();
  });
  wrapBtn.addEventListener('click', ()=>{
    wrapMode = !wrapMode;
    wrapBtn.textContent = wrapMode ? 'üîÅ Wrap: ON' : '‚õî Wrap: OFF';
  });

  // Init
  resizeCanvas(); // ajusta tama√±o desde el principio
  draw(false);
})();
</script>
</body>
</html>